<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>TinyGamepad Tester</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        background: #0e0e0e;
        color: #eee;
        font-family: 'Segoe UI', sans-serif;
        padding: 20px;
      }
      h1 {
        font-size: 24px;
      }
      label {
        display: block;
        margin-top: 1em;
      }
      input,
      button,
      select {
        padding: 0.5em;
        margin-top: 0.2em;
        font-size: 1em;
        background: #1f1f1f;
        color: #eee;
        border: 1px solid #444;
        border-radius: 4px;
      }
      textarea {
        width: 100%;
        height: 100px;
        background: #1a1a1a;
        color: #eee;
        border: 1px solid #444;
        margin-top: 0.5em;
      }
      #log {
        max-height: 300px;
        overflow-y: auto;
        background: #141414;
        padding: 10px;
        margin-top: 1em;
        font-family: monospace;
        font-size: 0.9em;
        border: 1px solid #333;
      }
      .section {
        margin-bottom: 2em;
      }
      .flex {
        display: flex;
        gap: 1em;
        flex-wrap: wrap;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <h1>üïπÔ∏è TinyGamepad Tester</h1>

    <div class="section">
      <label>
        Expected Gamepad ID:
        <input id="expectedId" type="text" placeholder="Leave empty to auto-select" value="" />
      </label>
      <label>
        Ignore Gamepad IDs (comma-separated):
        <input id="ignoreIds" type="text" value="Bluetooth Controller,Unknown Gamepad" />
      </label>
      <label>
        Deadzone:
        <input id="deadZone" type="number" step="0.01" min="0" max="1" value="0.1" />
      </label>
      <label> <input id="useKeyboardMouse" type="checkbox" /> Use Keyboard & Mouse Instead </label>
      <button id="initBtn">Initialize TinyGamepad</button>
    </div>

    <div class="section">
      <div class="flex">
        <label>
          Logical Input Name:
          <input id="logicalName" type="text" placeholder="e.g. Jump" />
        </label>
        <label>
          Physical Binding:
          <input id="physicalInput" type="text" placeholder="e.g. button0, KeyW, mouse0" />
        </label>
        <button id="mapInputBtn">Map Input</button>
      </div>
      <pre id="inputMappings"></pre>
    </div>

    <div class="section">
      <button id="exportBtn">üì§ Export Config (JSON)</button>
      <button id="importBtn">üì• Import Config</button>
      <textarea id="configJson" placeholder="Paste exported config here..."></textarea>
    </div>

    <div class="section">
      <button id="vibrateBtn">üîä Vibrate (200ms)</button>
    </div>

    <div class="section">
      <h2>üì° Live Sensor Feed</h2>
      <pre id="sensorOutput">Waiting for sensor data...</pre>
    </div>

    <div class="section">
      <h2>üì• Event Log</h2>
      <div id="log"></div>
    </div>

    <script type="module">
      import { TinyGamepad } from './src/v1/libs/TinyGamepad.mjs';

      let tg = null;

      const log = (msg) => {
        const box = document.getElementById('log');
        const line = document.createElement('div');
        line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        box.appendChild(line);
        box.scrollTop = box.scrollHeight;
      };

      const updateMappings = () => {
        // const pre = document.getElementById('inputMappings');
        // const mapped = [...tg.inputMap.entries()].map(([k, v]) => `${k} => ${v}`).join('\n');
        // pre.textContent = mapped || 'No mappings yet.';
      };

      const applyDefaultMappings = () => {
        const defaultBindings = {
          Jump: 'button0',
          Shoot: 'button1',
          MoveLeft: 'axis0-',
          MoveRight: 'axis0+',
          MoveUp: 'axis1-',
          MoveDown: 'axis1+',
          Reload: 'KeyR',
          Dash: 'mouse1',
        };

        for (const [logical, physical] of Object.entries(defaultBindings)) {
          tg.mapInput(logical, physical);
          tg.onInput(logical, (evt) => {
            log(`Mapped input "${logical}" triggered via ${evt.type} (${evt.key})`);
          });
        }
      };

      document.getElementById('initBtn').addEventListener('click', () => {
        const expectedId = document.getElementById('expectedId').value || null;
        const ignoreRaw = document.getElementById('ignoreIds').value;
        const ignoreIds = ignoreRaw
          .split(',')
          .map((s) => s.trim())
          .filter(Boolean);
        const deadZone = parseFloat(document.getElementById('deadZone').value);
        const useKeyboardMouse = document.getElementById('useKeyboardMouse').checked;

        tg = new TinyGamepad({
          expectedId,
          ignoreIds,
          deadZone,
          useKeyboardMouse,
        });

        tg.on('connected', (e) => log(`Gamepad connected: ${e.id}`));
        tg.on('disconnected', (e) => log(`Gamepad disconnected: ${e.id}`));
        tg.on('sensor', (data) => {
          const out = document.getElementById('sensorOutput');
          out.textContent = JSON.stringify(data, null, 2);
        });

        tg.mapInput('All', '*');
        tg.onInput('All', (evt) => console.log(`Input (ALL)`, evt));

        /** tg.onInput('*', (evt) => {
          console.log(
            `Input (*) "${evt.logicalName}" from ${evt.type} (${evt.key}) ${evt.value !== null ? `: ${evt.value}` : ''}`,
          );
        }); */

        applyDefaultMappings();
        updateMappings();
        log('TinyGamepad initialized with default configuration.');
      });

      document.getElementById('mapInputBtn').addEventListener('click', () => {
        if (!tg) return alert('Initialize TinyGamepad first!');
        const logical = document.getElementById('logicalName').value.trim();
        const physical = document.getElementById('physicalInput').value.trim();
        if (!logical || !physical) return alert('Please provide both logical and physical input.');
        tg.mapInput(logical, physical);
        tg.onInput(logical, (evt) => {
          log(`Mapped input "${logical}" triggered via ${evt.type} (${evt.input})`);
        });
        updateMappings();
      });

      document.getElementById('exportBtn').addEventListener('click', () => {
        if (!tg) return;
        document.getElementById('configJson').value = tg.exportConfig();
        log('Configuration exported.');
      });

      document.getElementById('importBtn').addEventListener('click', () => {
        if (!tg) return;
        try {
          const json = document.getElementById('configJson').value;
          tg.importConfig(json);
          updateMappings();
          log('Configuration imported.');
        } catch (err) {
          alert('Invalid JSON');
        }
      });

      document.getElementById('vibrateBtn').addEventListener('click', () => {
        if (!tg) return;
        const success = tg.vibrate?.();
        log(success ? 'Vibration triggered.' : 'Vibration not supported.');
      });
    </script>
  </body>
</html>
