<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>TinyGamepad Tester</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      /* Reset b√°sico */
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      * {
        scrollbar-width: thin;
        scrollbar-color: #4caf50 #1e1e1e;
      }

      *::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }

      *::-webkit-scrollbar-thumb {
        background-color: #4caf50;
        border-radius: 10px;
        border: 2px solid #1e1e1e;
      }

      *::-webkit-scrollbar-track {
        background: #1e1e1e;
        border-radius: 10px;
      }

      .json-pretty {
        font-family: monospace;
        font-size: 0.9rem;
        white-space: pre-wrap;
        word-break: break-word;
        color: #c5e1a5;
      }

      .json-key {
        color: #8bc34a;
      }

      .json-string {
        color: #f48fb1;
      }

      .json-number {
        color: #64b5f6;
      }

      .json-boolean {
        color: #ffd54f;
      }

      .json-null {
        color: #e57373;
      }

      .json-bracket {
        color: #9e9e9e;
        margin-left: -10px;
      }

      .json-indent {
        margin-left: 1.5em;
      }

      .json-line {
        margin: 2px 0;
      }

      .json-line:hover {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 4px;
      }

      body {
        background: #121212;
        color: #e0e0e0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        padding: 24px 32px;
        min-height: 100vh;
        margin: 0;
      }

      h1 {
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 24px;
        color: #76ff03;
        user-select: none;
      }

      h2 {
        font-size: 1.5rem;
        margin-bottom: 16px;
        border-bottom: 2px solid #4caf50;
        padding-bottom: 6px;
        user-select: none;
      }

      label {
        display: block;
        margin-top: 1.2em;
        font-weight: 600;
      }

      input[type='text'],
      input[type='number'],
      button,
      select,
      textarea {
        padding: 0.6em 0.8em;
        margin-top: 6px;
        font-size: 1rem;
        background: #1e1e1e;
        color: #e0e0e0;
        border: 1px solid #3a3a3a;
        border-radius: 6px;
        transition: border-color 0.2s ease;
        width: 100%;
      }

      input[type='number'] {
        max-width: 100px;
      }

      input[type='checkbox'] {
        width: auto;
        margin-right: 8px;
        vertical-align: middle;
        cursor: pointer;
      }

      button {
        background: #2a7f2a;
        border-color: #4caf50;
        color: #fff;
        font-weight: 700;
        cursor: pointer;
        border-radius: 6px;
        width: auto;
        padding-left: 1.2em;
        padding-right: 1.2em;
        user-select: none;
      }

      button:hover:not([disabled]) {
        background: #4caf50;
        border-color: #76ff03;
      }

      button:active:not([disabled]) {
        background: #388e3c;
      }

      button[disabled] {
        opacity: 0.5;
        cursor: not-allowed;
      }

      textarea {
        resize: vertical;
        min-height: 120px;
        font-family: monospace;
      }

      .section {
        margin-bottom: 3rem;
      }

      .flex {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: flex-end;
      }

      .flex > label {
        flex: 1 1 220px;
        min-width: 180px;
      }

      #inputMappings {
        background: #1b1b1b;
        border: 1px solid #333;
        color: #b3b3b3;
        font-family: monospace;
        padding: 12px;
        white-space: pre-wrap;
        border-radius: 6px;
        max-height: 180px;
        overflow-y: auto;
        margin-top: 1em;
      }

      #log {
        min-height: 320px;
        max-height: 320px;
        overflow-y: auto;
        background: #181818;
        padding: 14px 16px;
        margin-top: 1em;
        font-family: monospace;
        font-size: 0.9em;
        border-radius: 8px;
        border: 1px solid #222;
        color: #ccc;
      }

      /* Grid container para status */
      .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1rem 1.5rem;
      }

      .status-card {
        background: #1f1f1f;
        padding: 16px 20px;
        border-radius: 10px;
        box-shadow: 0 0 15px rgba(0, 255, 0, 0.15);
        font-weight: 600;
        user-select: none;
        height: 220px;
        max-height: 220px;
        margin-bottom: 20px;
        overflow-y: auto;
      }

      .status-label {
        display: block;
        font-size: 0.85rem;
        color: #8bc34a;
        margin-bottom: 6px;
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }

      .status-value {
        font-size: 1.1rem;
        color: #c5e1a5;
        overflow-wrap: anywhere;
        min-height: 1.2em;
        white-space: pre-wrap;
        max-height: 180px;
        overflow-y: auto;
      }

      /* Analog axes container */
      #analogsContainer {
        background: #1a1a1a;
        border-radius: 12px;
        padding: 16px 24px;
        box-shadow: inset 0 0 8px rgba(0, 255, 0, 0.25);
        user-select: none;
      }

      #analogsContainer > h3 {
        margin-top: 0;
        margin-bottom: 16px;
        color: #a5d6a7;
      }

      .analog-row {
        display: flex;
        align-items: center;
        margin-bottom: 12px;
      }

      .analog-label {
        width: 70px;
        font-weight: 600;
        color: #aed581;
      }

      .analog-bar {
        flex-grow: 1;
        height: 18px;
        background: #333;
        border-radius: 9px;
        overflow: hidden;
        margin: 0 12px;
        position: relative;
        box-shadow: inset 0 0 5px #000;
      }

      .analog-fill {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 50%;
        width: 50%;
        background: #76ff03;
        border-radius: 9px 0 0 9px;
        transform-origin: left center;
        transition: width 0.1s ease;
      }

      .analog-fill.negative {
        left: auto;
        right: 50%;
        border-radius: 0 9px 9px 0;
      }

      .analog-value {
        width: 48px;
        text-align: right;
        font-family: monospace;
        color: #c5e1a5;
        font-weight: 700;
      }

      /* Deadzone note */
      #deadZoneNote {
        font-size: 0.8rem;
        color: #999;
        font-style: italic;
        margin-top: 6px;
        user-select: none;
      }
    </style>
  </head>
  <body>
    <h1>üïπÔ∏è TinyGamepad Tester</h1>

    <div class="section">
      <label>
        Expected Gamepad ID:
        <input id="expectedId" type="text" placeholder="Leave empty to auto-select" value="" />
      </label>
      <label>
        Ignore Gamepad IDs (comma-separated):
        <input id="ignoreIds" type="text" value="Bluetooth Controller,Unknown Gamepad" />
      </label>
      <label>
        Deadzone:
        <input id="deadZone" type="number" step="0.01" min="0" max="1" value="0.1" />
        <div id="deadZoneNote">* Values below deadzone are ignored for analog axes.</div>
      </label>
      <label>
        <input id="useKeyboardMouse" type="checkbox" />
        Use Keyboard & Mouse Instead
      </label>
      <label>
        <input id="debugAllInputs" type="checkbox" checked />
        Debug all inputs
      </label>
      <button id="initBtn">Initialize TinyGamepad</button>
    </div>

    <div class="section">
      <h2>üéÆ Real-Time Status</h2>
      <div class="status-grid">
        <div class="status-card">
          <span class="status-label">Input Mode</span>
          <span id="mode" class="status-value">-</span>
        </div>
        <div class="status-card">
          <span class="status-label">Connected Gamepad</span>
          <span id="gamepadId" class="status-value">-</span>
        </div>
        <div class="status-card">
          <span class="status-label">Held Keys</span>
          <span id="heldKeys" class="status-value">-</span>
        </div>
        <div class="status-card">
          <span class="status-label">Active Mapped Inputs</span>
          <span id="activeMapped" class="status-value">-</span>
        </div>
        <div class="status-card">
          <span class="status-label">Combo Inputs</span>
          <span id="comboInputs" class="status-value">-</span>
        </div>
        <div class="status-card">
          <span class="status-label">Combo Keys</span>
          <span id="comboKeys" class="status-value">-</span>
        </div>
        <!-- Novo cart√£o para press√£o dos bot√µes -->
        <div class="status-card">
          <span class="status-label">Pressure Buttons (isPressure)</span>
          <span id="pressureButtons" class="status-value">-</span>
        </div>
      </div>
      <div id="analogsContainer">
        <h3>Analog Axes</h3>
        <!-- Analog axes dynamically generated here -->
      </div>
    </div>

    <div class="section">
      <div class="flex">
        <label>
          Logical Input Name:
          <input id="logicalName" type="text" placeholder="e.g. Jump" />
        </label>
        <label>
          Physical Binding:
          <input id="physicalInput" type="text" placeholder="e.g. button0, KeyW, mouse0" />
        </label>
        <button id="mapInputBtn">Map Input</button>
      </div>
      <pre id="inputMappings">No mappings yet.</pre>
    </div>

    <div class="section">
      <button id="exportBtn">üì§ Export Config (JSON)</button>
      <button id="importBtn">üì• Import Config</button>
      <textarea id="configJson" placeholder="Paste exported config here..."></textarea>
    </div>

    <div class="section">
      <button id="vibrateBtn">üîä Vibrate (200ms)</button>
    </div>

    <div class="section">
      <h2>üì° Live Sensor Feed</h2>
      <pre id="sensorOutput" class="json-pretty">Waiting for sensor data...</pre>
    </div>

    <div class="section">
      <h2>üì• Event Log</h2>
      <div id="log"></div>
    </div>

    <script type="module">
      import { TinyGamepad } from './src/v1/libs/TinyGamepad.mjs';

      let tg = null;

      const log = (msg) => {
        const box = document.getElementById('log');
        const line = document.createElement('div');
        line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        box.appendChild(line);
        box.scrollTop = box.scrollHeight;
      };

      // Atualiza o status da interface em tempo real
      const updateUI = () => {
        if (!tg) return;

        // Atualiza textos simples
        document.getElementById('heldKeys').textContent = [...tg.getHeldKeys()].join(', ') || '-';
        document.getElementById('activeMapped').textContent =
          [...tg.getActiveMappedInputs()].join(', ') || '-';
        document.getElementById('comboInputs').textContent =
          tg.getComboMappedInputs().join(', ') || '-';
        document.getElementById('comboKeys').textContent =
          tg.getComboMappedKeys().join(', ') || '-';
        document.getElementById('mode').textContent = tg.inputMode;
        document.getElementById('gamepadId').textContent = tg.hasGamepad()
          ? tg.getGamepad().id
          : 'None';

        // --- Atualiza√ß√£o dos bot√µes isPressure no Real-Time Status ---
        let pressureData = '-';
        if (tg.hasGamepad()) {
          const gp = tg.getGamepad();
          const buttons = gp.buttons;
          const pressedPressureButtons = [];
          buttons.forEach((btn, idx) => {
            // tinyGamepad adiciona isPressure? Vamos checar pressionamento sens√≠vel
            // O gamepad padr√£o tem btn.value e btn.pressed, mas "isPressure" n√£o √© nativo.
            // Vamos considerar bot√£o com valor > 0.1 e n√£o booleano puro como press√£o:
            if (btn.pressed && btn.value !== undefined && btn.value > 0.1) {
              pressedPressureButtons.push(`Button${idx}: ${btn.value.toFixed(2)}`);
            }
          });
          pressureData = pressedPressureButtons.length ? pressedPressureButtons.join('\n') : 'None';
        }
        document.getElementById('pressureButtons').textContent = pressureData;

        // Atualiza eixos anal√≥gicos
        const analogsContainer = document.getElementById('analogsContainer');

        // Limpa os eixos antes de atualizar
        // Preservamos o t√≠tulo h3, removendo outros elementos filhos
        [...analogsContainer.children]
          .filter((el) => el.tagName.toLowerCase() !== 'h3')
          .forEach((el) => analogsContainer.removeChild(el));

        if (tg.hasGamepad()) {
          const gp = tg.getGamepad();
          const axes = gp.axes;

          // Para cada eixo, cria a linha com barra e valor
          axes.forEach((value, index) => {
            // Aplica deadzone pra display: mostra 0 se dentro da deadzone
            const dz = tg.deadZone;
            const valToDisplay = Math.abs(value) < dz ? 0 : value;

            // Cria container da linha do eixo
            const row = document.createElement('div');
            row.className = 'analog-row';

            // Label do eixo
            const label = document.createElement('div');
            label.className = 'analog-label';
            label.textContent = `Axis ${index}`;

            // Barra do eixo
            const bar = document.createElement('div');
            bar.className = 'analog-bar';

            // Barra preenchida da esquerda ou direita, com base no sinal do valor
            const fill = document.createElement('div');
            fill.className = 'analog-fill';
            if (valToDisplay < 0) fill.classList.add('negative');

            // Valor absoluto para largura proporcional
            fill.style.width = `${Math.min(Math.abs(valToDisplay) * 100, 100)}%`;

            bar.appendChild(fill);

            // Valor num√©rico
            const valueSpan = document.createElement('div');
            valueSpan.className = 'analog-value';
            valueSpan.textContent = valToDisplay.toFixed(3);

            row.appendChild(label);
            row.appendChild(bar);
            row.appendChild(valueSpan);

            analogsContainer.appendChild(row);
          });
        } else {
          // Se n√£o tem gamepad conectado
          const noGp = document.createElement('div');
          noGp.style.color = '#999';
          noGp.style.fontStyle = 'italic';
          noGp.textContent = 'No gamepad connected to display analog data.';
          analogsContainer.appendChild(noGp);
        }
      };

      function renderPrettyJSON(container, data) {
        container.innerHTML = '';
        const root = formatValue(data, 0);
        container.appendChild(root);
      }

      function formatValue(value, depth) {
        const container = document.createElement('div');
        container.className = 'json-indent';

        if (Array.isArray(value)) {
          container.appendChild(createLine('[', 'json-bracket'));
          value.forEach((item, index) => {
            const line = document.createElement('div');
            line.className = 'json-line';
            const valNode = formatValue(item, depth + 1);
            line.appendChild(valNode);
            container.appendChild(line);
          });
          container.appendChild(createLine(']', 'json-bracket'));
        } else if (typeof value === 'object' && value !== null) {
          container.appendChild(createLine('{', 'json-bracket'));
          Object.entries(value).forEach(([key, val], index, arr) => {
            const line = document.createElement('div');
            line.className = 'json-line';
            const spanKey = document.createElement('span');
            spanKey.className = 'json-key';
            spanKey.textContent = `"${key}"`;
            line.appendChild(spanKey);
            line.appendChild(document.createTextNode(': '));
            const valNode = formatValue(val, depth + 1);
            line.appendChild(valNode);
            container.appendChild(line);
          });
          container.appendChild(createLine('}', 'json-bracket'));
        } else {
          let span = document.createElement('span');
          if (typeof value === 'string') {
            span.className = 'json-string';
            span.textContent = `"${value}"`;
          } else if (typeof value === 'number') {
            span.className = 'json-number';
            span.textContent = value;
          } else if (typeof value === 'boolean') {
            span.className = 'json-boolean';
            span.textContent = value;
          } else if (value === null) {
            span.className = 'json-null';
            span.textContent = 'null';
          }
          return span;
        }

        return container;
      }

      function createLine(text, className) {
        const line = document.createElement('div');
        line.className = 'json-line';
        const span = document.createElement('span');
        span.className = className;
        span.textContent = text;
        line.appendChild(span);
        return line;
      }

      // Atualiza o feed de sensores (girosc√≥pio, aceler√¥metro, b√∫ssola se houver)
      const updateSensorFeed = () => {
        if (!tg) return;

        const sensorOutput = document.getElementById('sensorOutput');

        if (!tg.hasGamepad()) {
          sensorOutput.textContent = 'No gamepad connected to display sensor data.';
          return;
        }

        const gp = tg.getGamepad();
        const sensors = tg.getGamepadSensors?.() || {};

        // Monta objeto com dados principais:
        const data = {
          timestamp: gp ? gp.timestamp : Date.now(),
          mouse: {
            x: lastMouseX ?? null,
            y: lastMouseY ?? null,
          },
          axes: gp.axes.map((v) => Number(v.toFixed(3))),
          buttons: gp.buttons.map((b) => ({
            pressed: b.pressed,
            value: Number(b.value.toFixed(3)),
          })),
          sensors: {},
        };

        // Se TinyGamepad implementa sensores
        if (sensors.gyroscope) {
          data.sensors.gyroscope = {
            x: sensors.gyroscope.x.toFixed(3),
            y: sensors.gyroscope.y.toFixed(3),
            z: sensors.gyroscope.z.toFixed(3),
          };
        }
        if (sensors.accelerometer) {
          data.sensors.accelerometer = {
            x: sensors.accelerometer.x.toFixed(3),
            y: sensors.accelerometer.y.toFixed(3),
            z: sensors.accelerometer.z.toFixed(3),
          };
        }
        if (sensors.compass) {
          data.sensors.compass = {
            heading: sensors.compass.heading.toFixed(3),
          };
        }

        renderPrettyJSON(sensorOutput, data);
      };

      let lastMouseX = null;
      let lastMouseY = null;
      window.addEventListener('mousemove', (e) => {
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      });

      // Loop para atualizar UI e sensor feed continuamente
      const startLiveUI = () => {
        const update = () => {
          updateUI();
          updateSensorFeed();
          requestAnimationFrame(update);
        };
        update();
      };

      const updateMappings = () => {
        const pre = document.getElementById('inputMappings');
        const mapped = [...tg.getActiveMappedInputs().entries()]
          .map(([k, v]) => `${k} ‚Üí ${Array.isArray(v) ? v.join(', ') : v}`)
          .join('\n');
        pre.textContent = mapped || 'No mappings yet.';
      };

      const applyDefaultMappings = () => {
        const defaultBindings = {
          Jump: 'Button0',
          Shoot: 'Button1',
          MoveLeft: 'Axis0-',
          MoveRight: 'Axis0+',
          MoveUp: 'Axis1-',
          MoveDown: 'Axis1+',
          Reload: ['KeyR', 'ShiftLeft'],
          Chat: 'KeyT',
          Action: 'KeyF',
          Dash: 'Mouse1',
        };

        for (const [logical, physical] of Object.entries(defaultBindings)) {
          tg.mapInput(logical, physical);
          tg.onInput(
            logical,
            (evt) =>
              evt.input &&
              log(`Mapped input "${logical}" triggered via ${evt.type} (${evt.input})`),
          );
        }
      };

      document.getElementById('initBtn').addEventListener('click', () => {
        if (tg) return;

        const expectedId = document.getElementById('expectedId').value || null;
        const ignoreRaw = document.getElementById('ignoreIds').value;
        const ignoreIds = ignoreRaw
          .split(',')
          .map((s) => s.trim())
          .filter(Boolean);
        const deadZone = parseFloat(document.getElementById('deadZone').value);
        const useKeyboardMouse = document.getElementById('useKeyboardMouse').checked;
        const debugAllInputs = document.getElementById('debugAllInputs').checked;

        if (useKeyboardMouse)
          document.addEventListener('contextmenu', (event) => event.preventDefault());

        tg = new TinyGamepad({
          expectedId,
          ignoreIds,
          deadZone,
          inputMode: useKeyboardMouse ? 'both' : 'gamepad-only',
          allowMouse: true,
        });
        window.tg = tg;

        tg.onConnected((e) => log(`Gamepad connected: ${e.id}`));
        tg.onDisconnected((e) => log(`Gamepad disconnected: ${e.id}`));

        tg.mapInput('All', '*');
        if (debugAllInputs) tg.onInput('All', (evt) => console.log(`Input (ALL)`, evt));

        tg.onMappedInputStart((evt) =>
          console.log(
            `Mapped Input Start`,
            evt,
            tg.getActiveMappedInputs(),
            tg.getComboMappedInputs(),
          ),
        );
        tg.onMappedInputEnd((evt) =>
          console.log(
            `Mapped Input End`,
            evt,
            tg.getActiveMappedInputs(),
            tg.getComboMappedInputs(),
          ),
        );

        if (debugAllInputs) {
          tg.onMappedKeyStart((evt) =>
            console.log(`Mapped Key Input Start`, evt, tg.getComboMappedKeys()),
          );
          tg.onMappedKeyEnd((evt) =>
            console.log(`Mapped Key Input End`, evt, tg.getComboMappedKeys()),
          );
        }

        tg.registerInputSequence(['Chat', 'Action'], (timestamp) =>
          console.log('Chat + Action', tg.getActiveMappedInputs(), timestamp),
        );

        tg.registerKeySequence(
          ['KeyP', 'KeyU', 'KeyD', 'KeyD', 'KeyI', 'KeyN', 'KeyG'],
          (timestamp) => console.log('Pudding cheat!', timestamp),
        );

        tg.onInput(
          '*',
          (evt) => debugAllInputs && evt.input && log(`Raw Input ${evt.input} from ${evt.type}`),
        );

        tg.onMappedInputStart(
          (evt) => evt.input && log(`Mapped Input Start: ${evt.logicalName} (${evt.input})`),
        );
        tg.onMappedInputEnd(
          (evt) => evt.input && log(`Mapped Input End: ${evt.logicalName} (${evt.input})`),
        );

        tg.onMappedKeyStart((evt) => log(`Mapped Key Start: ${evt.key}`));
        tg.onMappedKeyEnd((evt) => log(`Mapped Key End: ${evt.key}`));

        tg.registerInputSequence(['Chat', 'Action'], (timestamp) =>
          log(`Input Sequence Triggered! ${timestamp}`),
        );
        tg.registerKeySequence(
          ['KeyP', 'KeyU', 'KeyD', 'KeyD', 'KeyI', 'KeyN', 'KeyG'],
          (timestamp) => log('üü£ Secret Key Sequence Triggered (PUDDING)!'),
        );

        applyDefaultMappings();
        updateMappings();
        startLiveUI();
        log('TinyGamepad initialized!');
        document.getElementById('initBtn').setAttribute('disabled', true);
        document.getElementById('debugAllInputs').setAttribute('disabled', true);
        document.getElementById('useKeyboardMouse').setAttribute('disabled', true);
      });

      document.getElementById('mapInputBtn').addEventListener('click', () => {
        if (!tg) return alert('Initialize TinyGamepad first!');
        const logical = document.getElementById('logicalName').value.trim();
        const physical = document.getElementById('physicalInput').value.trim();
        if (!logical || !physical) return alert('Please provide both logical and physical input.');
        tg.mapInput(logical, physical);
        tg.onInput(logical, (evt) => {
          if (evt.input) log(`Mapped input "${logical}" triggered via ${evt.type} (${evt.input})`);
        });
        updateMappings();
      });

      document.getElementById('exportBtn').addEventListener('click', () => {
        if (!tg) return;
        document.getElementById('configJson').value = tg.exportConfig();
        log('Configuration exported.');
      });

      document.getElementById('importBtn').addEventListener('click', () => {
        if (!tg) return;
        try {
          const json = document.getElementById('configJson').value;
          tg.importConfig(json);
          updateMappings();
          log('Configuration imported.');
        } catch (err) {
          alert('Invalid JSON');
        }
      });

      document.getElementById('vibrateBtn').addEventListener('click', () => {
        if (!tg) return;
        const success = tg.vibrate?.({ duration: 200 });
        log(success ? 'Vibration triggered.' : 'Vibration not supported.');
      });
    </script>
  </body>
</html>
