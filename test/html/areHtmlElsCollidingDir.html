<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Collision Test</title>
    <style>
      body {
        margin: 0;
        height: 100vh;
        overflow: hidden;
        background: #f0f0f0;
        font-family: sans-serif;
      }

      #wall {
        position: absolute;
        top: 150px;
        left: 300px;
        width: 200px;
        height: 200px;
        background-color: #0077ff;
      }

      #box {
        position: absolute;
        top: 200px;
        left: 50px;
        width: 100px;
        height: 100px;
        background-color: red;
        cursor: grab;
        transition: box-shadow 0.2s;
      }

      #box.colliding {
        box-shadow: 0 0 10px 4px #ff0000;
      }
    </style>
  </head>
  <body>
    <div id="wall"></div>
    <div id="box"></div>

    <script>
      const box = document.getElementById('box');
      const wall = document.getElementById('wall');
      let offsetX, offsetY;
      let isDragging = false;

      const areElsCollTop = (rect1, rect2) => rect1.bottom < rect2.top;
      const areElsCollBottom = (rect1, rect2) => rect1.top > rect2.bottom;
      const areElsCollLeft = (rect1, rect2) => rect1.right < rect2.left;
      const areElsCollRight = (rect1, rect2) => rect1.left > rect2.right;

      const areElsCollPerfTop = (rect1, rect2) => rect1.bottom <= rect2.top;
      const areElsCollPerfBottom = (rect1, rect2) => rect1.top >= rect2.bottom;
      const areElsCollPerfLeft = (rect1, rect2) => rect1.right <= rect2.left;
      const areElsCollPerfRight = (rect1, rect2) => rect1.left >= rect2.right;

      const areElsColliding = (rect1, rect2) =>
        !(
          areElsCollLeft(rect1, rect2) ||
          areElsCollRight(rect1, rect2) ||
          areElsCollTop(rect1, rect2) ||
          areElsCollBottom(rect1, rect2)
        );

      const areElsPerfColliding = (rect1, rect2) =>
        !(
          areElsCollPerfLeft(rect1, rect2) ||
          areElsCollPerfRight(rect1, rect2) ||
          areElsCollPerfTop(rect1, rect2) ||
          areElsCollPerfBottom(rect1, rect2)
        );

      const getElsColliding = (rect1, rect2) => {
        if (areElsCollLeft(rect1, rect2)) return 'left';
        else if (areElsCollRight(rect1, rect2)) return 'right';
        else if (areElsCollTop(rect1, rect2)) return 'top';
        else if (areElsCollBottom(rect1, rect2)) return 'bottom';
        return null;
      };

      const getElsPerfColliding = (rect1, rect2) => {
        if (areElsCollPerfLeft(rect1, rect2)) return 'left';
        else if (areElsCollPerfRight(rect1, rect2)) return 'right';
        else if (areElsCollPerfTop(rect1, rect2)) return 'top';
        else if (areElsCollPerfBottom(rect1, rect2)) return 'bottom';
        return null;
      };

      const getElsCollOverlap = (rect1, rect2) => ({
        overlapLeft: rect2.right - rect1.left,
        overlapRight: rect1.right - rect2.left,
        overlapTop: rect2.bottom - rect1.top,
        overlapBottom: rect1.bottom - rect2.top,
      });

      const getElsCollOverlapPos = ({
        overlapLeft = -1,
        overlapRight = -1,
        overlapTop = -1,
        overlapBottom = -1,
      } = {}) => ({
        dirX: overlapLeft < overlapRight ? 'right' : 'left',
        dirY: overlapTop < overlapBottom ? 'bottom' : 'top',
      });

      function getElsCollDirDepth(rect1, rect2) {
        if (!areElsPerfColliding(rect1, rect2))
          return {
            dir: null,
            dirX: null,
            dirY: null,
            depthX: 0,
            depthY: 0,
          };

        const { overlapLeft, overlapRight, overlapTop, overlapBottom } = getElsCollOverlap(
          rect1,
          rect2,
        );
        const { dirX, dirY } = getElsCollOverlapPos({
          overlapLeft,
          overlapRight,
          overlapTop,
          overlapBottom,
        });
        const depthX = Math.min(overlapLeft, overlapRight);
        const depthY = Math.min(overlapTop, overlapBottom);

        /** @type {Dirs} */
        let dir;

        if (depthX < depthY) dir = dirX;
        else dir = dirY;
        return { dir, dirX, dirY, depthX, depthY };
      }

      function getElsCollDetails(rect1, rect2) {
        const isColliding = areElsPerfColliding(rect1, rect2);

        /** @type {{ dir: Dirs | null;  dirX: Dirs | null;  dirY: Dirs | null; }} */
        const dirs = { dir: null, dirX: null, dirY: null };

        /** @type {Record<Dirs, number>} */
        const depth = { top: 0, bottom: 0, left: 0, right: 0 };
        if (!isColliding) return { ...dirs, ...depth };

        const { overlapLeft, overlapRight, overlapTop, overlapBottom } = getElsCollOverlap(
          rect2,
          rect1,
        );
        depth.top = overlapTop;
        depth.bottom = overlapBottom;
        depth.left = overlapLeft;
        depth.right = overlapRight;

        /**
         * Detect the direction with the smallest positive overlap (entry point)
         * @type {[Dirs, number][]}
         */
        // @ts-ignore
        const entries = Object.entries(depth)
          .filter(([, val]) => val > 0)
          .sort((a, b) => a[1] - b[1]);

        const { dirX, dirY } = getElsCollOverlapPos({
          overlapLeft,
          overlapRight,
          overlapTop,
          overlapBottom,
        });
        dirs.dirY = dirX;
        dirs.dirX = dirY;
        dirs.dir = entries.length ? entries[0][0] : 'top'; // fallback in case of exact match
        return { ...dirs, ...depth };
      }

      function areHtmlElsCollidingWithLock(elem1, elem2, lockDirection, stateMap) {
        const rect1 = elem1.getBoundingClientRect();
        const rect2 = elem2.getBoundingClientRect();
        const isColliding = areElsColliding(rect1, rect2);
        console.log(getElsCollDetails(rect1, rect2));
        // console.log(getElsCollDirDepth(rect1, rect2));

        if (isColliding) {
          // Save entry direction
          if (!stateMap.has(elem1)) {
            stateMap.set(elem1, lockDirection);
          }
          return true;
        }

        // Handle unlock logic
        if (stateMap.has(elem1)) {
          const lastDirection = stateMap.get(elem1);

          switch (lastDirection) {
            case 'top':
              if (areElsCollTop(rect1, rect2)) stateMap.delete(elem1); // exited from top
              break;
            case 'bottom':
              if (areElsCollBottom(rect1, rect2)) stateMap.delete(elem1); // exited from bottom
              break;
            case 'left':
              if (areElsCollLeft(rect1, rect2)) stateMap.delete(elem1); // exited from left
              break;
            case 'right':
              if (areElsCollRight(rect1, rect2)) stateMap.delete(elem1); // exited from right
              break;
          }

          return stateMap.has(elem1); // still colliding (locked)
        }

        return false;
      }

      box.addEventListener('mousedown', (e) => {
        isDragging = true;
        offsetX = e.clientX - box.offsetLeft;
        offsetY = e.clientY - box.offsetTop;
        box.style.cursor = 'grabbing';
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
        box.style.cursor = 'grab';
      });

      const stateMap = new WeakMap();
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const x = e.clientX - offsetX;
        const y = e.clientY - offsetY;
        box.style.left = `${x}px`;
        box.style.top = `${y}px`;

        const colliding = areHtmlElsCollidingWithLock(box, wall, 'bottom', stateMap); // change 'right' if needed
        box.classList.toggle('colliding', colliding);
      });
    </script>
  </body>
</html>
